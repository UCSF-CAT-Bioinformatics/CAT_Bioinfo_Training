---
title: "Basics of Single Cell RNA-Seq Part 6: Clustering and cell type assignment"
author: "UCSF CAT Bioinformatics"
date: "`r Sys.Date()`"
output:
    html_document:
      keep_md: TRUE
      toc: TRUE
---

# Introduction to Single Cell RNA-Seq Part 6: Clustering and cell type assignment
Clustering and cell type assignment are critical steps in many single cell (or single nucleus) experiments. The power of single cell experiments is to capture the heterogeneity within samples as well as between them. Clustering permits the user to organize cells into clusters that correspond to biologically and experimentally relevant populations.
```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, error = FALSE)
```


## Set up workspace
```{r libraries}
library(Seurat)
library(presto)
library(kableExtra)
library(tidyr)
library(dplyr)
library(ggplot2)
library(HGNChelper)
library(ComplexHeatmap)
library(clustree)
```

We will be continuing the work from Part 1 and so need to load in the RDS file
```{r readRDS}
experiment.aggregate <- readRDS("scRNA_workshop-04.rds")
experiment.aggregate
```

Lets go ahead and set that common seed for everyone
```{r seed}
set.seed(12345)
```


## Construct network
Seurat implements an graph-based clustering approach. Distances between the cells are calculated based on previously identified PCs.

The default method for identifying k-nearest neighbors is [annoy](https://github.com/spotify/annoy), an approximate nearest-neighbor approach that is widely used for high-dimensional analysis in many fields, including single-cell analysis. Extensive community benchmarking has shown that annoy substantially improves the speed and memory requirements of neighbor discovery, with negligible impact to downstream results.
```{r FindNeighbors}
experiment.aggregate <- FindNeighbors(experiment.aggregate, reduction = "pca", dims = 1:50)
```

## Find clusters
The FindClusters function implements the neighbor based clustering procedure, and contains a resolution parameter that sets the granularity of the downstream clustering, with increased values leading to a greater number of clusters. This code produces a series of resolutions for us to investigate and choose from.

The clustering resolution parameter is unit-less and somewhat arbitrary. The resolutions used here were selected to produce a useable number of clusters in the example experiment. 
```{r FindClusters}
experiment.aggregate <- FindClusters(experiment.aggregate,
                                     resolution = seq(0.1, 0.6, 0.1))
```

Seurat adds the clustering information to the metadata table. Each FindClusters call generates a new column named with the assay, followed by "_snn_res.", and the resolution.
```{r cluster_metadata}
cluster.resolutions <- grep("res", colnames(experiment.aggregate[[]]), value = TRUE)
head(experiment.aggregate@meta.data[,cluster.resolutions]) %>%
  kable(caption = 'Cluster identities are added to the metadata.') %>%
  kable_styling("striped")
```

## Explore clustering resolutions
The number of clusters produced increases with the clustering resolution.
```{r clusters_per_res}
sapply(cluster.resolutions, function(res){
  length(levels(experiment.aggregate[[]][,res]))
})
```

### Visualize clustering

Dimensionality reduction plots can be used to visualize the clustering results. On these plots, we can see how each clustering resolution aligns with patterns in the data revealed by dimensionality reductions.

#### UMAP

```{r UMAP}
# UMAP colored by cluster
lapply(cluster.resolutions, function(res){
  DimPlot(experiment.aggregate,
          group.by = res,
          reduction = "umap",
          shuffle = TRUE) +
          scale_color_viridis_d(option = "turbo")
})
```

### Investigate the relationship between cluster identity and sample identity

```{r membership}
lapply(cluster.resolutions, function(res){
         tmp = experiment.aggregate@meta.data[,c(res, "orig.ident")]
         colnames(tmp) = c("cluster", "orig.ident")
         ggplot(tmp, aes(x = cluster, fill = orig.ident)) +
           geom_bar() +
           theme_classic()
})
```

### Investigate the relationship between cluster identity and metadata values
Here, example plots are displayed for the lowest resolution in order to save space. To see plots for each resolution, use `lapply()`.
```{r}
VlnPlot(experiment.aggregate,
        group.by = "RNA_snn_res.0.4",
        features = "nCount_RNA",
        pt.size = 0.1) +
  scale_fill_viridis_d(option = "turbo")
VlnPlot(experiment.aggregate,
        group.by = "RNA_snn_res.0.4",
        features = "nFeature_RNA",
        pt.size = 0.1) +
  scale_fill_viridis_d(option = "turbo")
VlnPlot(experiment.aggregate,
        group.by = "RNA_snn_res.0.4",
        features = "percent.mito",
        pt.size = 0.1) +
  scale_fill_viridis_d(option = "turbo")
```
 
### Visualize expression of genes of interest

```{r feature}
FeaturePlot(experiment.aggregate,
            reduction = "umap",
            features = "CDH1")
VlnPlot(experiment.aggregate,
        group.by = "RNA_snn_res.0.4",
        features = "CDH1",
        pt.size = 0.1) +
  scale_fill_viridis_d(option = "turbo")
```
Clustree creates a plot of a clustering tree showing the relationship between clusterings at different resolutions.

```{r select}
clustree(experiment.aggregate,prefix = "RNA_snn_res.")
```

## Select a resolution
For now, let's use resolution 0.4. Over the remainder of this section, we will refine the clustering further.
```{r assign}
experiment.aggregate[["seurat_clusters"]] <- experiment.aggregate[["RNA_snn_res.0.5"]]
Idents(experiment.aggregate) <- "seurat_clusters"
```

## Visualize cluster tree

Building a phylogenetic tree relating the 'average' cell from each group in default 'Ident' (currently "seurat_clusters"). This tree is estimated based on a distance matrix constructed in either gene expression space or PCA space.

```{r tree}
experiment.aggregate <- BuildClusterTree(experiment.aggregate, dims = 1:50)
PlotClusterTree(experiment.aggregate)
```
## Automated cell type detection

[ScType](https://www.nature.com/articles/s41467-022-28803-w) is one of many available automated cell type detection algorithms. It has the advantage of being fast and flexible; it can be used with the large human and mouse cell type database provided by the authors, with a user-defined database, or with some combination of the two.

In this section, we will use ScType to assign our clusters from Seurat to a cell type based on a hierarchical external database. The database supplied with the package is human but users can supply their own data. More details are available on [Github](https://github.com/IanevskiAleksandr/sc-type).

### Source ScType functions from Github
The `source()` functions in the code box below run scripts stored in the ScType GitHub repository. These scripts add two additional functions, `gene_sets_prepare()` and `sctype_score()`, to the global environment.
```{r source_scType}
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
```

### Create marker database
The authors of ScType have provided an extensive database of human and mouse cell type markers in the following tissues:

* Immune system
* Pancreas
* Liver
* Eye
* Kidney
* Brain
* Lung
* Adrenal
* Heart
* Intestine
* Muscle
* Placenta
* Spleen
* Stomach
* Thymus

To set up the database for ScType, we run the `gene_sets_prepare()` function on a URL pointing to the full database, specifying the tissue subset to retrieve.
```{r marker_database}
db.URL <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx"
tissue <- "Lung"
gs.list <- gene_sets_prepare(db.URL, cell_type = tissue)
```

```{r View_database, eval=FALSE}
View(gs.list)
```

The database is composed of two lists (negative and positive) of cell type markers for the specified tissue. In this case, no negative markers have been provided, so the vectors of gene names in that part of the database are empty (length 0).

In addition to using the database supplied with the package, or substituting another database, it is possible to augment the provided database by changing the provided markers for an existing cell type, or adding another cell type to the object.

### Score cells
ScType scores every cell, summarizing the transformed and weighted expression of markers for each cell type. This generates a matrix with the dimensions cell types x cells.
```{r score_cells}
es.max <- sctype_score(GetAssayData(experiment.aggregate, layer = "scale"),
                       scaled = TRUE,
                       gs = gs.list$gs_positive,
                       gs2 = gs.list$gs_negative)
# cell type scores of first cell
es.max[,1]
```

### Score clusters
The "ScType score" of each cluster is calculated by summing the cell-level scores within each cluster. The cell type with the largest (positive) score is the most highly enriched cell type for that cluster.
```{r score_clusters}
clusters <- sort(unique(experiment.aggregate$seurat_clusters))
tmp <- lapply(clusters, function(cluster){
  es.max.cluster = sort(rowSums(es.max[, experiment.aggregate$seurat_clusters == cluster]), decreasing = TRUE)
  out = head(data.frame(cluster = cluster,
                        ScType = names(es.max.cluster),
                        scores = es.max.cluster,
                        ncells = sum(experiment.aggregate$seurat_clusters == cluster)))
  out$rank = 1:length(out$scores)
  return(out)
})
cluster.ScType <- do.call("rbind", tmp)

cluster.ScType %>%
  pivot_wider(id_cols = cluster,
              names_from = ScType,
              values_from = scores) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped"), fixed_thead = TRUE)

cluster.ScType.top <- cluster.ScType %>%
  filter(rank == 1) %>%
  select(cluster, ncells, ScType, scores)

rownames(cluster.ScType.top) <- cluster.ScType.top$cluster
cluster.ScType.top <- cluster.ScType.top %>%
  rename(score = "scores")
```

Once the scores have been calculated for each cluster, they can be added to the Seurat object.
```{r add_ScType}
cluster.ScType <- cluster.ScType.top[experiment.aggregate$seurat_clusters, "ScType"]
experiment.aggregate <- AddMetaData(experiment.aggregate,
                                    metadata = cluster.ScType,
                                    col.name = "cluster_ScType")
DimPlot(experiment.aggregate,
        reduction = "umap",
        group.by = "cluster_ScType",
        shuffle = TRUE) +
  scale_color_viridis_d()
```

The ScType developer suggests that assignments with a score less than (number of cells in cluster)/4 are low confidence and should be set to unknown:
```{r adjust_confidence}
cluster.ScType.top <- cluster.ScType.top %>%
  mutate(ScType_filtered = ifelse(score >= ncells / 4, ScType, "Unknown"))
cluster.ScType.filtered <- cluster.ScType.top[experiment.aggregate$orig.ident, "ScType_filtered"]
experiment.aggregate <- AddMetaData(experiment.aggregate,
                                    metadata = cluster.ScType.filtered,
                                    col.name = "cluster_ScType_filtered")
DimPlot(experiment.aggregate,
        reduction = "umap",
        group.by = "cluster_ScType_filtered",
        shuffle = TRUE) +
  scale_color_viridis_d()
```

## Identify marker genes

Seurat provides several functions that can help you find markers that define clusters via differential expression:

* `FindMarkers` identifies markers for a cluster relative to all other clusters

* `FindAllMarkers` performs the find markers operation for all clusters

* `FindAllMarkersNode` defines all markers that split a node from the cluster tree

### FindMarkers

```{r FindMarkers}
markers <- FindMarkers(experiment.aggregate,
                       group.by = "seurat_clusters",
                       ident.1 = "12")
length(which(markers$p_val_adj < 0.05)) # how many are significant?
head(markers) %>%
  kable() %>%
  kable_styling("striped")
```

The "pct.1" and "pct.2" columns record the proportion of cells with normalized expression above 0 in ident.1 and ident.2, respectively. The "p_val" is the raw p-value associated with the differential expression test, while the BH-adjusted value is found in "p_val_adj". Finally, "avg_logFC" is the average log fold change difference between the two groups.

Marker genes identified this way can be visualized in violin plots, feature plots, and heat maps.
```{r view.markers}
view.markers <- c(rownames(markers[markers$avg_log2FC > 0,])[1],
                  rownames(markers[markers$avg_log2FC < 0,])[1])
lapply(view.markers, function(marker){
  VlnPlot(experiment.aggregate,
          group.by = "seurat_clusters",
          features = marker) +
    scale_fill_viridis_d(option = "turbo")
})
FeaturePlot(experiment.aggregate,
            features = view.markers,
            ncol = 2)
DoHeatmap(experiment.aggregate,
          slot="data",
          group.by = "seurat_clusters",
          features = view.markers,
          group.colors = viridis::turbo(length(levels(experiment.aggregate$seurat_clusters))))
```

#### Improved heatmap
The Seurat `DoHeatmap` function provided by Seurat provides a convenient look at expression of selected genes. The ComplexHeatmap library generates heat maps with a much finer level of control.
```{r ComplexHeatmap}
cluster.colors <- viridis::turbo(length(levels(experiment.aggregate$seurat_clusters)))
names(cluster.colors) <- levels(experiment.aggregate$seurat_clusters)
group.colors <- viridis::mako(length(levels(experiment.aggregate$group)))
names(group.colors) <- levels(experiment.aggregate$group)
top.annotation <- columnAnnotation(df = experiment.aggregate@meta.data[,c("orig.ident", "seurat_clusters")],
                                   col = list(group = group.colors,
                                              seurat_clusters = cluster.colors))
mat <- as.matrix(GetAssayData(experiment.aggregate[rownames(markers)[1:20],],
                              slot = "data"))
Heatmap(mat,
        name = "normalized\ncounts",
        show_row_dend = FALSE,
        show_column_dend = FALSE,
        show_column_names = FALSE,
        top_annotation = top.annotation)
```


### FindAllMarkers
FindAllMarkers can be used to automate this process across all clusters.
```{r FindAllMarkers, eval=FALSE}
Idents(experiment.aggregate) <- "seurat_clusters"
markers <- FindAllMarkers(experiment.aggregate,
                          only.pos = TRUE,
                          min.pct = 0.25,
                          thresh.use = 0.25)
tapply(markers$p_val_adj, markers$cluster, function(x){
  length(x < 0.05)
})
head(markers) %>%
  kable() %>%
  kable_styling("striped")

view.markers <- tapply(markers$gene, markers$cluster, function(x){head(x,1)})
# violin plots
lapply(view.markers, function(marker){
  VlnPlot(experiment.aggregate,
          group.by = "seurat_clusters",
          features = marker) +
    scale_fill_viridis_d(option = "turbo")
})
# feature plots
lapply(view.markers, function(marker){
  FeaturePlot(experiment.aggregate,
              features = marker)
})
```


```{r FindAllMarkers_heat, fig.width=10}
# heat map
DoHeatmap(experiment.aggregate,
          slot="data",
          group.by = "seurat_clusters",
          features = view.markers,
          group.colors = viridis::turbo(length(unique(experiment.aggregate$seurat_clusters))))
# ComplexHeatmap
mat <- as.matrix(GetAssayData(experiment.aggregate[view.markers,],
                              slot = "data"))
Heatmap(mat,
        name = "normalized\ncounts",
        show_row_dend = FALSE,
        show_column_dend = FALSE,
        show_column_names = FALSE,
        column_split = experiment.aggregate$seurat_clusters,
        top_annotation = top.annotation)
```

#### Calculate mean marker expression within clusters
You may want to get an idea of the mean expression of markers in a cluster or group of clusters. The percent expressing is provided by FindMarkers and FindAllMarkers, along with the average log fold change, but not the expression value itself. The function below calculates a mean for the supplied marker in the named cluster(s) and all other groups. Please note that this function accesses the active identity.
```{r means}
# ensure active identity is set to desired clustering resolution
Idents(experiment.aggregate) <- experiment.aggregate$seurat_clusters
# define function
getGeneClusterMeans <- function(feature, idents){
  x = GetAssayData(experiment.aggregate)[feature,]
  m = tapply(x, Idents(experiment.aggregate) %in% idents, mean)
  names(m) = c("mean.out.of.idents", "mean.in.idents")
  return(m[c(2,1)])
}
# calculate means for a single marker
getGeneClusterMeans(view.markers[0], c("1"))

# add means to marker table (example using subset)
markers.small <- markers[view.markers,]
means <- matrix(mapply(getGeneClusterMeans, view.markers, markers.small$cluster), ncol = 2, byrow = TRUE)
colnames(means) <- c("mean.in.cluster", "mean.out.of.cluster")
rownames(means) <- view.markers
markers.small <- cbind(markers.small, means)
markers.small[,c("cluster", "mean.in.cluster", "mean.out.of.cluster", "avg_log2FC", "p_val_adj")] %>%
  kable() %>%
  kable_styling("striped")
```

## Combine ScType clusters with Markers
```{r cell_type_heat}
types <- grep("Unknown", unique(experiment.aggregate$cluster_ScType), value = TRUE, invert = TRUE)
type.markers <- unlist(lapply(gs.list$gs_positive[types], function(m){
  rownames(markers[which(m %in% rownames(markers)),])
}))
type.markers <- type.markers[!duplicated(type.markers)]
type.markers.df <- data.frame(marker = type.markers,
                              type = gsub('[0-9]', '', names(type.markers)))
type.colors <- viridis::viridis(length(unique(type.markers.df$type)))
names(type.colors) <- unique(type.markers.df$type)
left.annotation <- rowAnnotation("marker" = type.markers.df$type, col = list(marker = type.colors))
mat <- as.matrix(GetAssayData(experiment.aggregate,
                              slot = "data")[type.markers.df$marker,])
Heatmap(mat,
        name = "normalized\ncounts",
        top_annotation = top.annotation,
        left_annotation = left.annotation,
        show_column_dend = FALSE,
        show_column_names = FALSE,
        show_row_dend = FALSE)
```



## Cluster Management (Optional)
In many experiments, the clustering resolution does not need to be uniform across all of the cell types present. While for some cell types of interest fine detail may be desirable, for others, simply grouping them into a larger parent cluster is sufficient. Merging cluster is very straightforward.
```{r merge}
experiment.aggregate.original <- experiment.aggregate
Idents(experiment.aggregate) <- "seurat_clusters"
experiment.aggregate <- RenameIdents(experiment.aggregate,
                                     '14' = '13')
experiment.aggregate$res.0.5_merged <- Idents(experiment.aggregate)

table(experiment.aggregate$res.0.5_merged)

experiment.aggregate@meta.data %>%
  ggplot(aes(x = res.0.5_merged, fill = orig.ident)) +
  geom_bar() +
  scale_fill_viridis_d(option = "mako") +
  theme_classic()
DimPlot(experiment.aggregate,
        reduction = "umap",
        group.by = "res.0.5_merged",
        label = TRUE) +
  scale_color_viridis_d(option = "turbo")
VlnPlot(experiment.aggregate,
        group.by = "res.0.5_merged",
        features = "CDH1") +
  scale_fill_viridis_d(option = "turbo")
```

## Reorder the clusters
Merging the clusters changed the order in which they appear on a plot. In order to reorder the clusters for plotting purposes take a look at the levels of the identity, then re-level as desired.
```{r relevel}
levels(experiment.aggregate$res.0.5_merged)
# move one cluster to the first position
experiment.aggregate$res.0.5_merged <- relevel(experiment.aggregate$res.0.5_merged, "0")
levels(experiment.aggregate$res.0.5_merged)
# the color assigned to some clusters will change
VlnPlot(experiment.aggregate,
        group.by = "res.0.5_merged",
        features = "CAPN9",
        pt.size = 0.1) +
  scale_fill_viridis_d(option = "turbo")
# re-level entire factor
new.order <- as.character(sort(as.numeric(levels(experiment.aggregate$res.0.5_merged))))
experiment.aggregate$res.0.5_merged <- factor(experiment.aggregate$res.0.5_merged, levels = new.order)
levels(experiment.aggregate$res.0.5_merged)
VlnPlot(experiment.aggregate,
        group.by = "res.0.5_merged",
        features = "GPD1",
        pt.size = 0.1) +
  scale_fill_viridis_d(option = "turbo")
```

## Subcluster
While merging clusters reduces the resolution in some parts of the experiment, sub-clustering has the opposite effect. Let's produce sub-clusters for cluster 5.
```{r subcluster}
experiment.aggregate <- FindSubCluster(experiment.aggregate,
                                       graph.name = "RNA_snn",
                                       cluster = 5,
                                       subcluster.name = "seurat_clusters")
experiment.aggregate$subcluster <- factor(experiment.aggregate$seurat_clusters,
                                          levels = c(as.character(0:4),
                                                     "5_0", "5_1", "5_2", "5_3",
                                                     as.character(c(6:10, 13, 14))))
DimPlot(experiment.aggregate,
        reduction = "umap",
        group.by = "seurat_clusters",
        shuffle = TRUE) +
  scale_color_viridis_d(option = "turbo")
```

## Subset experiment by cluster identity
After exploring and refining the cluster resolution, we may have identified some clusters that are composed of cells we aren't interested in. For example, if we have identified a cluster likely composed of contaminants, this cluster can be removed from the analysis. Alternatively, if a group of clusters have been identified as particularly of interest, these can be isolated and re-analyzed.
```{r subset}
# remove cluster 13
Idents(experiment.aggregate) <- experiment.aggregate$subcluster
experiment.tmp <- subset(experiment.aggregate, subcluster != "13")
DimPlot(experiment.tmp,
        reduction = "umap",
        group.by = "seurat_clusters",
        shuffle = TRUE) +
  scale_color_viridis_d(option = "turbo")
# retain cells belonging only to specified clusters
experiment.tmp <- subset(experiment.aggregate, subcluster %in% c("1", "2", "5_0", "5_1", "5_2", "5_3", "7"))
DimPlot(experiment.tmp,
        reduction = "umap",
        group.by = "subcluster",
        shuffle = TRUE) +
  scale_color_viridis_d(option = "turbo")
```


## Advanced visualizations
Researchers may use the tree, markers, domain knowledge, and goals to identify useful clusters. This may mean adjusting PCA to use, choosing a new resolution, merging clusters together, sub-clustering, sub-setting, etc. You may also want to use automated cell type identification at this point, which will be discussed in the next section.


### Highlight a subset
```{r highlight}
DimPlot(experiment.aggregate,
        group.by = "subcluster",
        cells.highlight = CellsByIdentities(experiment.aggregate, idents = c("1", "2", "3")),
        cols.highlight = c(viridis::viridis(3))) +
  ggtitle("Selected clusters")
```

### Split dimensionality reduction plots
```{r split}
DimPlot(experiment.aggregate,
        group.by = "subcluster",
        split.by = "group") +
  scale_color_viridis_d(option = "turbo")
```

### Plot a subset of cells
Note that the object itself is unchanged by the subsetting operation.
```{r plot.subset}
DimPlot(experiment.aggregate,
        group.by = "subcluster",
        reduction = "umap",
        cells = Cells(experiment.aggregate)[experiment.aggregate$orig.ident %in% "LRTI_WRK1"]) +
  scale_color_viridis_d(option = "turbo") +
  ggtitle("LRTI_WRK1 subcluster")
```


## Prepare for the next section

#### Save the Seurat object and download the next Rmd file
```{r saveRDS}
experiment.aggregate <- experiment.aggregate.original
# save object
saveRDS(experiment.aggregate, file="scRNA_workshop-05.rds")
```

#### Download the Rmd file
```{r download_Rmd, eval=TRUE}
download.file("https://raw.githubusercontent.com/ucsf-cat-bioinformatics/2024-08-SCRNA-Seq-Analysis/main/data_analysis/06-de_enrichment.Rmd", "06-de_enrichment.Rmd")
```

#### Session Information
```{r sessionInfo}
sessionInfo()
```
