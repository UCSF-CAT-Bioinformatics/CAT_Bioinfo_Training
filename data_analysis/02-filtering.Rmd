---
title: "Basics of Single Cell RNA-Seq Part 2: QA and filtering"
author: "UCSF CAT Bioinformatics"
date: "`r Sys.Date()`"
output:
    html_document:
      keep_md: TRUE
      toc: TRUE
---

# Introduction to Single Cell RNA-Seq Part 2: QA and filtering
```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, error = FALSE)
```

## Set up workspace
First, we need to load the required libraries.
```{r libraries}
library(Seurat)
library(ggplot2)
library(tidyr)
library(dplyr)
library(kableExtra)
```

If you are continuing directly from part 1, the experiment.aggregate object is likely already in your workspace. In case you cleared your workspace at the end of the previous section, or are working on this project at a later date after re-starting R, you can use the `readRDS` function to read your saved Seurat object from part 1.

```{r readRDS}
experiment.aggregate <- readRDS("scRNA_workshop-01.rds")
experiment.aggregate
```

#### First lets look at the number of valid cells in each batch

```{r samples_table, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE}
textra <- as.data.frame(table(experiment.aggregate$orig.ident))
colnames(textra) <- c("Sample", "Number of Cells")
kable(textra, table.attr = "style='width:50%;'", caption="Cell counts per sample") %>% kable_styling("striped")
```

A seed is used to initialize pseudo-random functions. Some of the functions we will be using have pseudo-random elements. Setting a common seed ensures that all of us will get the same results, and that the results will remain stable when re-run.
```{r seed}
set.seed(12345)
```

## Display metadata QA/QC

Using a few nested functions, we can produce prettier, more detailed, versions of the simple exploratory summary statistics we generated for the available metadata in the last section. In the code below sections below,

Further, Seurat has a number of convenient built-in functions for visualizing metadata. These functions produce ggplot objects, which can easily be modified using ggplot2. Of course, all of these visualizations can be reproduced with custom code as well, and we will include some examples of both modifying Seurat plots and generating plots from scratch as the analysis continues.

1) 10% quantile tables are produced for each metadata value, separated by sample identity.
2) Ridge Plot
3) Violin Plot

Each is a different way of looking at the data as to get a better understanding of how each sample compares

#### Feature counts (genes) per cell
```{r nFeature, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
textra <- as.data.frame(do.call("cbind", tapply(experiment.aggregate$nFeature_RNA, Idents(experiment.aggregate), quantile, probs=seq(0,1,0.05))))
kable(textra, table.attr = "style='width:50%;'", caption="Feature count distribution by sample") %>% kable_styling("striped")
RidgePlot(experiment.aggregate, features="nFeature_RNA")
VlnPlot(experiment.aggregate, layer = "counts", features=c("nFeature_RNA"))
```

#### UMI counts per cell

```{r nCount, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
textra <- as.data.frame(do.call("cbind", tapply(experiment.aggregate$nCount_RNA, Idents(experiment.aggregate),quantile,probs=seq(0,1,0.05))))
kable(textra, table.attr = "style='width:50%;'", caption="UMI count distribution by sample") %>% kable_styling("striped")
RidgePlot(experiment.aggregate, features="nCount_RNA")
VlnPlot(experiment.aggregate, layer = "counts", features=c("nCount_RNA"))
```

#### Percentage of Mitochondria per cell 

```{r pMito, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
textra <- as.data.frame(round(do.call("cbind", tapply(experiment.aggregate$percent.mito, Idents(experiment.aggregate),quantile,probs=seq(0,1,0.05))), digits = 3))
kable(textra, table.attr = "style='width:50%;'", caption="Mitochondrial percentage distribution by sample") %>% kable_styling("striped")
RidgePlot(experiment.aggregate, features="percent.mito")
VlnPlot(experiment.aggregate, layer = "counts", features=c("percent.mito"))
```

#### Percentage of Ribosomal (protein) per cell 

```{r pRibo, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
textra <- as.data.frame(round(do.call("cbind", tapply(experiment.aggregate$percent.ribosomal, Idents(experiment.aggregate),quantile,probs=seq(0,1,0.05))), digits = 3))
kable(textra, table.attr = "style='width:50%;'", caption="Ribosomal percentage distribution by sample") %>% kable_styling("striped")
RidgePlot(experiment.aggregate, features="percent.ribosomal")
VlnPlot(experiment.aggregate, layer = "counts", features=c("percent.ribosomal"))
```

#### Modifying Seurat plots

Modifying the ggplot objects produced by a Seurat plotting function works best on individual panels. Therefore, to recreate the function above with modifications, we can use `lapply` to create a list of plots. In some cases it may be more appropriate to create the plots individually so that different modifications can be applied to each plot.

```{r violins_list}
VlnPlot(experiment.aggregate, features = "nCount_RNA", pt.size = 0.01) + 
  scale_y_continuous(trans = "log10") +
  scale_fill_viridis_d(option = "mako") +
  ggtitle("log10(nCount_RNA)")
```

These can later be stitched together with another library, like patchwork, or cowplot.

### Custom plots
The Seurat built-in functions are useful and easy to interact with, but sometimes you may wish to visualize something for which a plotting function does not already exist. For example, we might want to see how many cells are expressing each gene over some UMI threshold.

The code below produces a ranked plot similar to the barcode inflection plots from the last section. On the x-axis are the genes arranged from least ubiquitously expressed to most. In a single cell dataset, many genes are expessed in a relatively small number of cells, or not at all. The y-axis displays the number of cells in which each gene is expressed.

**Note: This function is SLOW. You may want to skip this code block or run it while you take a break for a few minutes.**
```{r gene_range}
plot(sort(Matrix::rowSums(GetAssayData(experiment.aggregate) >= 3)) , xlab="gene rank", ylab="number of cells", main="Cells per genes (reads/gene >= 3 )")
```   

### Scatter plots
Scatter plots allow us to visualize the relationships between the metadata variables.

Gene Plot, scatter plot of gene expression across cells, (colored by sample)
```{r gene_plot, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
plot1 <- FeatureScatter(experiment.aggregate, feature1 = "nCount_RNA", feature2 = "percent.mito",pt.size = 0.5)
plot2 <- FeatureScatter(experiment.aggregate, feature1 = "nFeature_RNA", feature2 = "percent.mito",pt.size = 0.5)
plot3 <- FeatureScatter(experiment.aggregate, feature1 = "nCount_RNA", feature2 = "nFeature_RNA",pt.size = 0.5)
plot1
plot2
plot3
```

### Cell filtering

We use the information above to filter out cells. Here we choose those that have percent mitochondrial genes max of 10% and unique UMI counts under 50,000 or greater than 500. Further requiring the number of features persent per cell to be 1000 genes.

```{r filterviz, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
qc.metrics <- experiment.aggregate[[]] %>%
as_tibble(
  rownames="Cell.Barcode"
)

qc.metrics %>%
  arrange(percent.mito) %>%
  ggplot(aes(nCount_RNA,nFeature_RNA,colour=percent.mito)) + 
  geom_point(size=0.7) + 
  scale_color_gradientn(colors=c("black","blue","green2","red","yellow")) +
  ggtitle("RNA Count vs RNA Features, colored by percent Mitochondrial (LOG Scaled)") +
  geom_hline(yintercept = 500) +
  geom_hline(yintercept = 7000) +
  scale_x_log10() + scale_y_log10()
```  

## Cell Complexity

The standard way of calculating this is log10(genes)/log10(counts) however this gives absolute values which are difficult to judge. A possibly better approach is to fit a line through the cloud and then calculate the difference from the observed value to the expected.

```{r complex, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
qc.metrics <- qc.metrics %>%
  mutate(complexity=log10(nFeature_RNA) / log10(nCount_RNA))

complexity.lm <- lm(log10(qc.metrics$nFeature_RNA)~log10(qc.metrics$nCount_RNA))
complexity.lm

qc.metrics <- qc.metrics %>%
  mutate(
    complexity_diff = log10(nFeature_RNA) - ((log10(qc.metrics$nCount_RNA)*complexity.lm$coefficients[2])+complexity.lm$coefficients[1])
  )

qc.metrics %>%
  ggplot(aes(x=complexity_diff)) +
  geom_density(fill="yellow")

```  
And we can add the information to the scatter plot

```{r complexplot, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
complexity_scale <- min(c(max(qc.metrics$complexity_diff),0-min(qc.metrics$complexity_diff)))

qc.metrics %>%
  mutate(complexity_diff=replace(complexity_diff,complexity_diff< -0.1,-0.1)) %>%
  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, colour=complexity_diff)) +
  geom_point(size=0.5) +
  geom_abline(slope=complexity.lm$coefficients[2], intercept = complexity.lm$coefficients[1]) +
  scale_colour_gradient2(low="blue2",mid="grey",high="red2") +
  scale_x_log10() + scale_y_log10()
```  
  
  
### Histograms of metadata

Histograms can also be useful to look at the distribution over all the cells

```{r count_hist, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
qc.metrics %>%
ggplot(aes((nCount_RNA))) + 
geom_histogram(binwidth = 0.05, fill="yellow", colour="black") +
ggtitle("Distribution of UMI Counts") +
geom_vline(xintercept = 1000) + 
geom_vline(xintercept = 100000) + scale_x_log10()

```  

Displaying the number of genes per cell

```{r features_hist, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
qc.metrics %>%
  ggplot(aes(nFeature_RNA)) + 
  geom_histogram(binwidth = 0.05, fill="yellow", colour="black") +
  ggtitle("Distribution of Feature Counts") +
  geom_vline(xintercept = 750) +
  geom_vline(xintercept = 8000) + scale_x_log10() 
```  


With Mitochondrial expression

```{r mito_hist, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
qc.metrics %>%
  ggplot(aes(percent.mito)) + 
  geom_histogram(binwidth = 0.5, fill="yellow", colour="black") +
  ggtitle("Distribution of Percentage Mitochondrion") +
  geom_vline(xintercept = 15)
```  


## Cell filtering
The goal of cell filtering is to remove cells with anomolous expression profiles, typically low UMI cells, which may correspond to low-quality cells or background barcodes. It may also be appropriate to remove outlier cells with extremely high UMI counts.
In this case, the proposed cut-offs on the high end of the distributions are quite conservative, in part to reduce the size of the object and speed up analysis during the workshop.


These filters can be put in place with the `subset` function.

#### Prefiltered data

```{r filtered_table_pre, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE}
textra <- as.data.frame(table(experiment.aggregate$orig.ident))
colnames(textra) <- c("Sample", "Number of Cells")
kable(textra, table.attr = "style='width:50%;'", caption="Cell countse per sample") %>% kable_styling("striped")
```


```{r filtering, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE}
experiment.aggregate.filtered <- subset(
  experiment.aggregate,
    nFeature_RNA>750 & 
    nFeature_RNA<8000 & 
    percent.mito < 15
)

```

#### Post filtered data

```{r filtered_table_post, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE}
textra <- as.data.frame(table(experiment.aggregate.filtered$orig.ident))
colnames(textra) <- c("Sample", "Number of Cells")
kable(textra, table.attr = "style='width:50%;'", caption="Cell countse per sample") %>% kable_styling("striped")
```

**Play with the filtering parameters, and see how the results change. Is there a set of parameters you feel is more appropriate? Why?**

## Feature filtering

When creating the base Seurat object, we had the opportunity filter out some genes using the "min.cells" argument. At the time, we set the min feature to keep a cell to 300. Since we didn't filter out any features then (set to 0), we can apply a filter at this point. If we had filtered when the object was created, this would be an opportunity to be more aggressive. The custom code below provides a function that filters genes requiring a min.umi in at least min.cells, or takes a user-provided list of genes.


```{r gene_filter}
# define function
FilterGenes <- function(object, min.umi = NA, min.cells = NA, genes = NULL) {
  genes.use = NA
  if (!is.null(genes)) {
    genes.use = intersect(rownames(object), genes)
    } else if (min.cells & min.umi) {
      num.cells = Matrix::rowSums(GetAssayData(object) >= min.umi)
      genes.use = names(num.cells[which(num.cells >= min.cells)])
    }
  object = object[genes.use,]
  object = LogSeuratCommand(object = object)
  return(object)
}
# apply filter
experiment.filter <- FilterGenes(object = experiment.aggregate.filtered, min.umi = 1, min.cells = 2)
# filtering results
experiment.filter
```
## We are going to choose to not filter the genes at this time, but know you can

```{r filteredviz, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
qc.metrics <- experiment.aggregate.filtered[[]] %>%
as_tibble(
  rownames="Cell.Barcode"
)

qc.metrics %>%
  arrange(orig.ident) %>%
    ggplot(aes(nCount_RNA,nFeature_RNA,colour=orig.ident)) + 
  geom_point(size=0.7) + 
  ggtitle("Plotting RNA Count vs RNA Features, colored by sample id (LOG Scaled") +
  scale_x_log10() + scale_y_log10()
```  

## Prepare for the next section

#### Save object
```{r saveRDS}
saveRDS(experiment.aggregate.filtered, file="scRNA_workshop-02.rds")
```

#### Download Rmd
```{r}
download.file("https://raw.githubusercontent.com/ucsf-cat-bioinformatics/2024-08-SCRNA-Seq-Analysis/main/data_analysis/03-normalize_scale.Rmd", "03-normalize_scale.Rmd")
```

#### Session Information
```{r session_info}
sessionInfo()
```
