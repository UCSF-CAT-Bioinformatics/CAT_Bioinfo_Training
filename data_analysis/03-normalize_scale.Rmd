---
title: "Basics of Single Cell RNA-Seq Part 3: Normalize and scale"
author: "UCSF CAT Bioinformatics"
output:
    html_document:
      keep_md: TRUE
---

# Introduction to Single Cell RNA-Seq Part 3: Normalize and scale
```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

## Set up workspace
First, we need to load the required libraries.
```{r workspace}
library(Seurat)
library(kableExtra)
library(ggplot2)
library(dplyr)
```

We will be continuing the work from Part 1 and so need to load in the RDS file
```{r readRDS}
experiment.aggregate <- readRDS("scRNA_workshop-02.rds")
experiment.aggregate
```

Lets go ahead and set that common seed for everyone
```{r seed}
set.seed(12345)
```

## Normalize the data

After filtering, the next step is to normalize the data. We employ a global-scaling normalization method, LogNormalize, that normalizes the gene expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and then log-transforms the data.

```{r normalize_help, eval=FALSE}
?NormalizeData
```


```{r normalize}
experiment.aggregate <- NormalizeData(
  object = experiment.aggregate,
  normalization.method = "LogNormalize",
  scale.factor = 10000)
```

```{r normalize_review}
experiment.aggregate
```

The function produces a new layer in the object called "data". We can now access the normalised data using LayerData. We can use this to show that we can get a list of the most highly expressed genes overall.

```{r normalize_check}
norm.expression <- LayerData(experiment.aggregate,layer="data")

mean.expression <- apply(norm.expression, 1, mean)

names(mean.expression) <- rownames(experiment.aggregate)

mean.expression <- sort(mean.expression, decreasing = TRUE)

head(mean.expression, n=50)
```

We see a number of Mitochondrial genes that are highly expressed as well as some of our Ribosomal products.

```{r normalize_view_gene, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
ggplot(mapping = aes(LayerData(experiment.aggregate)["MALAT1",])) + 
  geom_histogram(binwidth = 0.05, fill="blue", colour="black") + 
  ggtitle("MALAT1 expression")
```
**Explore a couple more of these genes**

## Cell cycle assignment
Cell cycle phase can be a significant source of variation in single cell and single nucleus experiments. There are a number of automated cell cycle stage detection methods available for single cell data. For this workshop, we will be using the built-in Seurat cell cycle function, `CellCycleScoring`. This tool compares gene expression in each cell to a list of cell cycle marker genes and scores each barcode based on marker expression. The phase with the highest score is selected for each barcode. Seurat includes a list of cell cycle genes in human single cell data.

Seurat comes with the human gene lists needed for Cell Cycle determination.

```{r human_gene_list}
cc.genes.updated.2019
```

For other species, a user-provided gene list may be substituted, or the orthologs of the human gene list used instead.
**Do not run the code below for human experiments!**

```{r convert_list_mouse, eval=FALSE}
# mouse code DO NOT RUN for human data
library(biomaRt)
convertHumanGeneList <- function(x){
  require("biomaRt")
  human = useEnsembl("ensembl",
                     dataset = "hsapiens_gene_ensembl",
                     mirror = "uswest")
  mouse = useEnsembl("ensembl",
                     dataset = "mmusculus_gene_ensembl",
                     mirror = "uswest")
  genes = getLDS(attributes = c("hgnc_symbol"),
                 filters = "hgnc_symbol",
                 values = x ,
                 mart = human,
                 attributesL = c("mgi_symbol"),
                 martL = mouse,
                 uniqueRows=T)
  humanx = unique(genes[, 2])
  print(head(humanx)) # print first 6 genes found to the screen
  return(humanx)
}
# convert lists to mouse orthologs
s.genes <- convertHumanGeneList(cc.genes.updated.2019$s.genes)
g2m.genes <- convertHumanGeneList(cc.genes.updated.2019$g2m.genes)
```

Once an appropriate gene list has been identified, the `CellCycleScoring` function can be run.
```{r CellCycleScoring}
experiment.aggregate <- CellCycleScoring(experiment.aggregate,
                                         s.features = cc.genes.updated.2019$s.genes,
                                         g2m.features = cc.genes.updated.2019$g2m.genes,
                                         set.ident = TRUE)

table(experiment.aggregate[["Phase"]]) %>%
  kable(caption = "Number of Cells in each Cell Cycle Stage",
        col.names = c("Stage", "Count"),
        align = "c") %>%
  kable_styling()
```

We can visualize how the algorithm assigns state based on the computed S.Score and G2M.Score

```{r cellcycle_scoring, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
experiment.aggregate[[]] %>%
  ggplot(aes(x=S.Score, y=G2M.Score, color=Phase)) + 
  geom_point() +
  coord_cartesian(xlim=c(-0.5,0.5), ylim=c(-0.5,0.5))
```

Because the "set.ident" argument was set to TRUE (this is also the default behavior), the active identity of the Seurat object was changed to the phase. To return the active identity to the sample identity, use the `Idents` function.

```{r update_ident}
table(Idents(experiment.aggregate))
Idents(experiment.aggregate) <- "orig.ident"
table(Idents(experiment.aggregate))
```

## Identify variable genes

The function FindVariableFeatures identifies the most highly variable genes (default 2000 genes) by fitting a line to the relationship of log(variance) and log(mean) using loess smoothing, uses this information to standardize the data, then calculates the variance of the standardized data.  This helps avoid selecting genes that only appear variable due to their expression level.

```{r find_variable_genes_help, eval=FALSE}
?FindVariableFeatures
```


```{r find_variable_genes}
experiment.aggregate <- FindVariableFeatures(
  object = experiment.aggregate,
  selection.method = "vst") ## vst having issues??

length(VariableFeatures(experiment.aggregate))
```
The function places data in an object called HVFInfo, we can extract and look at the results of find variable features for each gene.

```{r get_HVFinfo, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE}
hvfinfo <-HVFInfo(experiment.aggregate) %>%
  arrange(desc(variance.standardized))

hvfinfo %>%
  head(n=20)
```

We can plot this data, while marking the top 20

```{r var_feature_plot, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE}
var.feat.plot <- VariableFeaturePlot(experiment.aggregate)
var.feat.plot <- LabelPoints(plot = var.feat.plot, points = rownames(hvfinfo)[1:20], repel = TRUE)
var.feat.plot
```

```{r hvfplot, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.width=10}
HVFInfo(experiment.aggregate) %>%
  arrange(desc(variance.standardized)) %>%
  mutate(index=1:n()) %>%
  ggplot(aes(x=index, y=variance.standardized)) +
  geom_line() +
  scale_x_log10() +
  geom_vline(xintercept = 2000, colour="blue")
```

Goes mostly flat at around 100, so we will keep our list of variable genes

```{r hvfinfo, warning=FALSE,error=FALSE, message=FALSE, echo=FALSE, fig.align="center", fig.width=10}
variance.data <- HVFInfo(experiment.aggregate) %>%
  as_tibble(rownames="Gene") %>%
  mutate(hypervariable = Gene %in% VariableFeatures((experiment.aggregate)))

variance.data %>% 
  ggplot(aes(log(mean),log(variance),color=hypervariable)) + 
  geom_point() + 
  scale_color_manual(values=c("black","blue"))  
```


**How do the results change if you use selection.method = "dispersion" or selection.method = "mean.var.plot"?**

FindVariableFeatures isn't the only way to set the "variable features" of a Seurat object. Another reasonable approach is to select a set of "minimally expressed" genes.
```{r minimally_expressed_genes}
min.value <- 2
min.cells <- 10

num.cells <- Matrix::rowSums(GetAssayData(experiment.aggregate, slot = "count") > min.value)
genes.use <- names(num.cells[which(num.cells >= min.cells)])
length(genes.use)

VariableFeatures(experiment.aggregate) <- genes.use
```

## Prepare for the next section

#### Save object
```{r}
saveRDS(experiment.aggregate, file = "scRNA_workshop-03.rds")
```

#### Download Rmd
```{r}
download.file("https://raw.githubusercontent.com/ucsf-cat-bioinformatics/2024-08-SCRNA-Seq-Analysis/main/data_analysis/04-dimensionality_reduction.Rmd", "04-dimensionality_reduction.Rmd")
```

#### Session Information
```{r session_info, warning=FALSE,error=FALSE,message=FALSE}
sessionInfo()
```
